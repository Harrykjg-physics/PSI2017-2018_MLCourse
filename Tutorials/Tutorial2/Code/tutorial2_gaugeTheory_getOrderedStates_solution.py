############ PHYS 777: MACHINE LEARNING FOR MANY-BODY PHYSICS, TUTORIAL 2 ############
### Dataset and code by Lauren Hayward Sierens and Juan Carrasquilla
###
### This code generates topologically-ordered configurations of the classical Ising
### gauge theory and saves them to the file 'orderedStates.txt'. The configurations
### are generated by applying local and non-local updates to an initial
### topologically-ordered reference configuration (all spins up).
######################################################################################

import numpy as np
import random

### Input parameters: ###
L = 17           # Linear size of the lattice
N_sites = L**2   # Total number of lattice sites
N_spins = 2*L**2 # Total number of spins (one spin on each link)
N_configs = 100  # Number of configurations to be generated

### Store each lattice site's four nearest neighbours in a neighbours array (using periodic boundary conditions): ###
neighbours = np.zeros((N_sites,4),dtype=np.int)
for i in range(N_sites):
  #neighbour to the right:
  neighbours[i,0]=i+1
  if i%L==(L-1):
    neighbours[i,0]=i+1-L
  
  #upwards neighbour:
  neighbours[i,1]=i+L
  if i >= (N_sites-L):
    neighbours[i,1]=i+L-N_sites
  
  #neighbour to the left:
  neighbours[i,2]=i-1
  if i%L==0:
    neighbours[i,2]=i-1+L
  
  #downwards neighbour:
  neighbours[i,3]=i-L
  if i <= (L-1):
    neighbours[i,3]=i-L+N_sites
#end of for loop

### Function to calculate the product of spins on plaquette i: ###
def getPlaquetteProduct(spins,i):
  return spins[2*i]*spins[(2*i)+1]*spins[2*neighbours[i,1]]*spins[(2*neighbours[i,0])+1]

### Define the gauge update at site i (for part a): ###
def gaugeUpdate(spins,i):
    indices = [ 2*i, 2*i+1, 2*neighbours[i,2], 2*neighbours[i,3]+1 ]
    for j in indices:
        spins[j]   = -spins[j]

### Define an update capable of changing Wx (for part b): ###
def topologicalUpdate_vertical(spins,ry):
    indices = 2*ry + 2*L*np.arange(L)
    for j in indices:
        spins[j]   = -spins[j]

### Define an update capable of changing Wy (for part b): ###
def topologicalUpdate_horizontal(spins,rx):
    indices = 2*L*rx + 2*np.arange(L) + 1
    for j in indices:
        spins[j]   = -spins[j]

fileName = 'orderedStates.txt'
file     = open(fileName, 'w')

state = np.array([-1 for i in range(N_spins)])
for j in range(100):
    # Apply many gauge updates (for part a):
    for k in range(N_sites):
        site = random.randint(0,N_sites-1)
        gaugeUpdate(state,site)
    # Possibly apply a random topolgoical update (vertical) to the dual lattice
    # to change Wx (for part b):
    if random.randint(0,1): # Randomly choose whether to apply the update
        col = random.randint(0,L-1) # Choose a column at random
        topologicalUpdate_vertical(state,col)
    # Possibly apply a random topolgoical update (horizontal) to the dual lattice
    # to change Wy (for part b)::
    if random.randint(0,1): # Randomly choose whether to apply the update
        row = random.randint(0,L-1) # Choose a row at random
        topologicalUpdate_horizontal(state,row)

    # Write to file:
    for s in state:
        file.write('%d ' %s)
    file.write('\n')
